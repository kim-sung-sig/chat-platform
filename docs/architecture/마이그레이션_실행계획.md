# ì±„íŒ… í”Œë«í¼ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰ ê³„íš

## ğŸ¯ ëª©í‘œ

í˜„ì¬ êµ¬ì¡°ë¥¼ DDD ê¸°ë°˜ ë©€í‹°ëª¨ë“ˆ êµ¬ì¡°ë¡œ ì¬êµ¬ì¶•

---

## ğŸ“‹ í˜„ì¬ ë¬¸ì œì 

### 1. JPA ì„¤ì • ë¬¸ì œ

- `chat-storage`ì— JPAê°€ ìˆì§€ë§Œ ë‹¤ë¥¸ ëª¨ë“ˆì—ì„œ Entityë¥¼ ì¸ì‹í•˜ì§€ ëª»í•¨
- `@EntityScan`, `@EnableJpaRepositories` ì„¤ì • ëˆ„ë½
- `chat-storage`ê°€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ëª¨ë“ˆì´ì§€ë§Œ JPA Configurationì´ ê° ì„œë²„ì— ë¶„ì‚°

### 2. ë„ë©”ì¸ ë¡œì§ ë¶„ì‚°

- ë„ë©”ì¸ ì„œë¹„ìŠ¤ê°€ ê° ì„œë²„ ëª¨ë“ˆì— í©ì–´ì ¸ ìˆìŒ
- ì¤‘ë³µ ì½”ë“œ ë°œìƒ ê°€ëŠ¥ì„±
- ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ íŒŒì•… ì–´ë ¤ì›€

### 3. Entity ë¯¸ì‚¬ìš©

- `chat-storage`ì˜ Entityë“¤ì´ ì‹¤ì œë¡œ ì‚¬ìš©ë˜ì§€ ì•ŠìŒ
- ê° ì„œë²„ì—ì„œ ìì²´ì ìœ¼ë¡œ Repository ì •ì˜

### 4. ì±…ì„ ë¶ˆëª…í™•

- Domain Modelê³¼ Entityê°€ í˜¼ì¬
- ì–´ë””ì— ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ë‘¬ì•¼ í• ì§€ ë¶ˆëª…í™•

---

## ğŸ—ï¸ ìƒˆë¡œìš´ êµ¬ì¡°

```
chat-platform/
â”œâ”€â”€ common-util          (ê³µí†µ ìœ í‹¸, ì˜ˆì™¸, ìƒìˆ˜)
â”œâ”€â”€ common-auth          (ì¸ì¦/ì¸ê°€)
â”œâ”€â”€ common-logging       (ë¡œê¹…)
â”œâ”€â”€ chat-domain          â­ NEW: ìˆœìˆ˜ ë„ë©”ì¸ + ì¸í„°í˜ì´ìŠ¤
â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”œâ”€â”€ channel/
â”‚   â”‚   â”œâ”€â”€ message/
â”‚   â”‚   â”œâ”€â”€ schedule/
â”‚   â”‚   â””â”€â”€ user/
â”‚   â””â”€â”€ service/
â”œâ”€â”€ chat-storage         âœï¸ ìˆ˜ì •: JPA êµ¬í˜„
â”‚   â”œâ”€â”€ entity/
â”‚   â”œâ”€â”€ repository/
â”‚   â”œâ”€â”€ adapter/         â­ NEW: Repository êµ¬í˜„
â”‚   â””â”€â”€ mapper/          â­ NEW: Entity â†” Domain ë³€í™˜
â”œâ”€â”€ chat-message-server  âœï¸ ë¦¬íŒ©í† ë§
â”œâ”€â”€ chat-system-server   âœï¸ ë¦¬íŒ©í† ë§
â””â”€â”€ chat-websocket-server âœï¸ ë¦¬íŒ©í† ë§
```

---

## ğŸ“ ì‹¤í–‰ ë‹¨ê³„

### âœ… Step 0: ì¤€ë¹„ ì‘ì—…

- [x] ì•„í‚¤í…ì²˜ ë¬¸ì„œ ì‘ì„±
- [ ] í˜„ì¬ ì½”ë“œ ë°±ì—…
- [ ] Git ë¸Œëœì¹˜ ìƒì„± (`feature/architecture-refactoring`)

---

### ğŸ”¹ Step 1: chat-domain ëª¨ë“ˆ ìƒì„±

#### 1.1 ëª¨ë“ˆ ìƒì„±

```bash
mkdir -p chat-domain/src/main/java/com/example/chat/domain
mkdir -p chat-domain/src/test/java/com/example/chat/domain
```

#### 1.2 build.gradle ì‘ì„±

```gradle
plugins {
    id 'java'
}

dependencies {
    implementation project(':common-util')
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
}
```

#### 1.3 ë„ë©”ì¸ ëª¨ë¸ ì •ì˜

**Channel Domain**

```
chat-domain/src/main/java/com/example/chat/domain/
â”œâ”€â”€ channel/
â”‚   â”œâ”€â”€ Channel.java              (Aggregate Root)
â”‚   â”œâ”€â”€ ChannelId.java            (Value Object)
â”‚   â”œâ”€â”€ ChannelType.java          (Enum)
â”‚   â”œâ”€â”€ ChannelMember.java        (Entity)
â”‚   â”œâ”€â”€ ChannelRepository.java    (Interface)
â”‚   â””â”€â”€ ChannelReader.java        (Interface - ì½ê¸° ì „ìš©)
```

**Message Domain**

```
â”œâ”€â”€ message/
â”‚   â”œâ”€â”€ Message.java              (Aggregate Root)
â”‚   â”œâ”€â”€ MessageId.java            (Value Object)
â”‚   â”œâ”€â”€ MessageType.java          (Enum: TEXT, IMAGE, FILE, SYSTEM)
â”‚   â”œâ”€â”€ MessageStatus.java        (Enum: PENDING, SENT, DELIVERED, READ, FAILED)
â”‚   â”œâ”€â”€ MessageContent.java       (Value Object)
â”‚   â”œâ”€â”€ MessageRepository.java    (Interface)
â”‚   â””â”€â”€ MessageReader.java        (Interface - ì½ê¸° ì „ìš©)
```

**Schedule Domain**

```
â”œâ”€â”€ schedule/
â”‚   â”œâ”€â”€ ScheduleRule.java         (Aggregate Root)
â”‚   â”œâ”€â”€ ScheduleId.java           (Value Object)
â”‚   â”œâ”€â”€ ScheduleType.java         (Enum: ONE_TIME, RECURRING)
â”‚   â”œâ”€â”€ ScheduleStatus.java       (Enum: PENDING, ACTIVE, EXECUTED, CANCELLED)
â”‚   â”œâ”€â”€ CronExpression.java       (Value Object)
â”‚   â”œâ”€â”€ ScheduleRuleRepository.java (Interface)
â”‚   â””â”€â”€ ScheduleReader.java       (Interface - ì½ê¸° ì „ìš©)
```

**User Domain**

```
â””â”€â”€ user/
    â”œâ”€â”€ User.java                 (Aggregate Root)
    â”œâ”€â”€ UserId.java               (Value Object)
    â””â”€â”€ UserRepository.java       (Interface)
```

#### 1.4 ë„ë©”ì¸ ì„œë¹„ìŠ¤ ì •ì˜

```
chat-domain/src/main/java/com/example/chat/domain/service/
â”œâ”€â”€ MessageDomainService.java
â”œâ”€â”€ ChannelDomainService.java
â””â”€â”€ ScheduleDomainService.java
```

#### 1.5 ê³µí†µ Value Objects

```
chat-domain/src/main/java/com/example/chat/domain/common/
â”œâ”€â”€ Cursor.java
â”œâ”€â”€ PageResult.java
â””â”€â”€ DomainEvent.java
```

---

### ğŸ”¹ Step 2: chat-storage ë¦¬íŒ©í† ë§

#### 2.1 ë””ë ‰í† ë¦¬ êµ¬ì¡° ì •ë¦¬

```
chat-storage/src/main/java/com/example/chat/storage/
â”œâ”€â”€ entity/                    âœï¸ ê¸°ì¡´ Entity ì •ë¦¬
â”‚   â”œâ”€â”€ ChatChannelEntity.java
â”‚   â”œâ”€â”€ ChatMessageEntity.java
â”‚   â”œâ”€â”€ MessageReadEntity.java
â”‚   â”œâ”€â”€ ScheduleRuleEntity.java
â”‚   â””â”€â”€ OutboxEventEntity.java
â”œâ”€â”€ repository/                âœï¸ JPA Repository
â”‚   â”œâ”€â”€ JpaChatChannelRepository.java
â”‚   â”œâ”€â”€ JpaChatMessageRepository.java
â”‚   â”œâ”€â”€ JpaMessageReadRepository.java
â”‚   â””â”€â”€ JpaScheduleRuleRepository.java
â”œâ”€â”€ adapter/                   â­ NEW: Domain Repository êµ¬í˜„
â”‚   â”œâ”€â”€ ChannelRepositoryAdapter.java
â”‚   â”œâ”€â”€ MessageRepositoryAdapter.java
â”‚   â”œâ”€â”€ ScheduleRepositoryAdapter.java
â”‚   â”œâ”€â”€ ChannelReaderAdapter.java
â”‚   â””â”€â”€ MessageReaderAdapter.java
â”œâ”€â”€ mapper/                    â­ NEW: ë³€í™˜ ë¡œì§
â”‚   â”œâ”€â”€ ChannelMapper.java
â”‚   â”œâ”€â”€ MessageMapper.java
â”‚   â””â”€â”€ ScheduleMapper.java
â””â”€â”€ config/
    â””â”€â”€ JpaConfig.java         âœï¸ ìˆ˜ì •
```

#### 2.2 Entityì— Enum ì¶”ê°€

```java
// MessageStatus.java (chat-domainìœ¼ë¡œ ì´ë™)
public enum MessageStatus {
    PENDING,
    SENT,
    DELIVERED,
    READ,
    FAILED
}

// ScheduleStatus.java (chat-domainìœ¼ë¡œ ì´ë™)
public enum ScheduleStatus {
    PENDING,
    ACTIVE,
    EXECUTED,
    CANCELLED,
    FAILED
}

// ScheduleType.java (chat-domainìœ¼ë¡œ ì´ë™)
public enum ScheduleType {
    ONE_TIME,
    RECURRING
}
```

#### 2.3 Adapter êµ¬í˜„ ì˜ˆì‹œ

```java
@Repository
@RequiredArgsConstructor
public class MessageRepositoryAdapter implements MessageRepository {
    private final JpaChatMessageRepository jpaRepository;
    private final MessageMapper mapper;
    
    @Override
    public Message save(Message message) {
        ChatMessageEntity entity = mapper.toEntity(message);
        ChatMessageEntity saved = jpaRepository.save(entity);
        return mapper.toDomain(saved);
    }
    
    @Override
    public Optional<Message> findById(MessageId id) {
        return jpaRepository.findById(id.getValue())
            .map(mapper::toDomain);
    }
    
    @Override
    public List<Message> findByChannelId(ChannelId channelId, Cursor cursor, int limit) {
        // QueryDSLì„ í™œìš©í•œ ì»¤ì„œ ê¸°ë°˜ í˜ì´ì§•
        // ...
    }
}
```

#### 2.4 JpaConfig ìˆ˜ì •

```java
@Configuration
@EnableJpaRepositories(basePackages = "com.example.chat.storage.repository")
@EntityScan(basePackages = "com.example.chat.storage.entity")
public class JpaConfig {
    // JPA ì„¤ì •
}
```

#### 2.5 build.gradle ìˆ˜ì •

```gradle
dependencies {
    implementation project(':common-util')
    implementation project(':chat-domain')  // â­ ì¶”ê°€
    
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    runtimeOnly 'org.postgresql:postgresql'
    
    // QueryDSL
    implementation "com.querydsl:querydsl-jpa:${querydslVersion}:jakarta"
    annotationProcessor "com.querydsl:querydsl-apt:${querydslVersion}:jakarta"
}
```

---

### ğŸ”¹ Step 3: chat-message-server ë¦¬íŒ©í† ë§

#### 3.1 íŒ¨í‚¤ì§€ êµ¬ì¡° ë³€ê²½

```
chat-message-server/src/main/java/com/example/chat/message/
â”œâ”€â”€ application/               â­ NEW: Use Case
â”‚   â”œâ”€â”€ SendMessageUseCase.java
â”‚   â”œâ”€â”€ PublishMessageUseCase.java
â”‚   â””â”€â”€ MarkMessageReadUseCase.java
â”œâ”€â”€ presentation/              âœï¸ ê¸°ì¡´ controller ì´ë™
â”‚   â”œâ”€â”€ MessageController.java
â”‚   â”œâ”€â”€ MessageReadController.java
â”‚   â””â”€â”€ dto/
â”‚       â”œâ”€â”€ request/
â”‚       â””â”€â”€ response/
â”œâ”€â”€ infrastructure/            âœï¸ ê¸°ì¡´ redis, event
â”‚   â”œâ”€â”€ redis/
â”‚   â”‚   â””â”€â”€ RedisMessagePublisher.java
â”‚   â””â”€â”€ event/
â”‚       â””â”€â”€ MessageEventPublisher.java
â””â”€â”€ config/
    â”œâ”€â”€ SecurityConfig.java
    â””â”€â”€ RedisConfig.java
```

#### 3.2 Use Case êµ¬í˜„ (Early Return íŒ¨í„´)

```java
@Service
@RequiredArgsConstructor
public class SendMessageUseCase {
    private final MessageRepository messageRepository;
    private final ChannelRepository channelRepository;
    private final MessageDomainService messageDomainService;
    private final RedisMessagePublisher redisPublisher;
    
    @Transactional
    public MessageResponse execute(SendMessageCommand command) {
        // 1. ì±„ë„ ì¡°íšŒ (Key â†’ Domain)
        Channel channel = channelRepository.findById(command.channelId())
            .orElseThrow(() -> new ChannelNotFoundException(command.channelId()));
        
        // 2. Early Return: ê¶Œí•œ ê²€ì¦
        if (!channel.isMember(command.senderId())) {
            throw new UnauthorizedAccessException("Not a member of channel");
        }
        
        // 3. Early Return: ì±„ë„ ìƒíƒœ ê²€ì¦
        if (!channel.isActive()) {
            throw new InactiveChannelException("Channel is not active");
        }
        
        // 4. ë„ë©”ì¸ ì„œë¹„ìŠ¤ë¡œ ë©”ì‹œì§€ ìƒì„±
        Message message = messageDomainService.createMessage(
            channel.getId(),
            command.senderId(),
            command.content()
        );
        
        // 5. ì €ì¥
        Message saved = messageRepository.save(message);
        
        // 6. ì´ë²¤íŠ¸ ë°œí–‰
        redisPublisher.publish(saved);
        
        // 7. ì‘ë‹µ
        return MessageResponse.from(saved);
    }
}
```

#### 3.3 ControllerëŠ” ì–‡ê²Œ ìœ ì§€

```java
@RestController
@RequestMapping("/api/v1/messages")
@RequiredArgsConstructor
public class MessageController {
    private final SendMessageUseCase sendMessageUseCase;
    
    @PostMapping
    public ResponseEntity<MessageResponse> sendMessage(
        @Valid @RequestBody SendMessageRequest request,
        @AuthenticationPrincipal UserPrincipal principal
    ) {
        SendMessageCommand command = SendMessageCommand.of(
            request,
            principal.getUserId()
        );
        
        MessageResponse response = sendMessageUseCase.execute(command);
        
        return ResponseEntity.ok(response);
    }
}
```

#### 3.4 build.gradleì— ì˜ì¡´ì„± ì¶”ê°€

```gradle
dependencies {
    implementation project(':common-util')
    implementation project(':common-auth')
    implementation project(':common-logging')
    implementation project(':chat-domain')    // â­ ì¶”ê°€
    implementation project(':chat-storage')   // â­ ì¶”ê°€
    
    // ... ê¸°ì¡´ ì˜ì¡´ì„±
}
```

#### 3.5 application.ymlì— JPA ì„¤ì • ì¶”ê°€

```yaml
spring:
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        default_batch_fetch_size: 100
```

---

### ğŸ”¹ Step 4: chat-system-server ë¦¬íŒ©í† ë§

#### 4.1 íŒ¨í‚¤ì§€ êµ¬ì¡° ë³€ê²½

```
chat-system-server/src/main/java/com/example/chat/system/
â”œâ”€â”€ application/               â­ NEW: Use Case
â”‚   â”œâ”€â”€ channel/
â”‚   â”‚   â”œâ”€â”€ CreateChannelUseCase.java
â”‚   â”‚   â”œâ”€â”€ JoinChannelUseCase.java
â”‚   â”‚   â””â”€â”€ LeaveChannelUseCase.java
â”‚   â”œâ”€â”€ message/
â”‚   â”‚   â””â”€â”€ QueryMessageUseCase.java (Cursor ê¸°ë°˜)
â”‚   â””â”€â”€ schedule/
â”‚       â”œâ”€â”€ CreateOneTimeScheduleUseCase.java
â”‚       â”œâ”€â”€ CreateRecurringScheduleUseCase.java
â”‚       â”œâ”€â”€ CancelScheduleUseCase.java
â”‚       â””â”€â”€ ForcePublishScheduleUseCase.java
â”œâ”€â”€ presentation/              âœï¸ Controller
â”‚   â”œâ”€â”€ ChannelController.java
â”‚   â”œâ”€â”€ MessageQueryController.java
â”‚   â”œâ”€â”€ ScheduleController.java
â”‚   â””â”€â”€ dto/
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ scheduler/
â”‚   â”‚   â”œâ”€â”€ MessagePublishJob.java
â”‚   â”‚   â”œâ”€â”€ QuartzSchedulerService.java
â”‚   â”‚   â””â”€â”€ ConcurrencyGuard.java
â”‚   â””â”€â”€ client/
â”‚       â””â”€â”€ MessageServerClient.java (REST í˜¸ì¶œ)
â””â”€â”€ config/
    â”œâ”€â”€ QuartzConfig.java
    â””â”€â”€ RestTemplateConfig.java
```

#### 4.2 Cursor ê¸°ë°˜ ë©”ì‹œì§€ ì¡°íšŒ

```java
@Service
@RequiredArgsConstructor
public class QueryMessageUseCase {
    private final MessageRepository messageRepository;
    private final ChannelRepository channelRepository;
    
    @Transactional(readOnly = true)
    public MessagePageResponse execute(QueryMessageCommand command) {
        // 1. ì±„ë„ ì¡°íšŒ
        Channel channel = channelRepository.findById(command.channelId())
            .orElseThrow(() -> new ChannelNotFoundException(command.channelId()));
        
        // 2. Early Return: ê¶Œí•œ ê²€ì¦
        if (!channel.isMember(command.userId())) {
            throw new UnauthorizedAccessException("Not a member");
        }
        
        // 3. Cursor ê¸°ë°˜ ì¡°íšŒ (Offset ê¸°ë°˜ ì•„ë‹˜!)
        List<Message> messages = messageRepository.findByChannelId(
            command.channelId(),
            command.cursor(),
            command.limit()
        );
        
        // 4. ë‹¤ìŒ ì»¤ì„œ ìƒì„±
        Cursor nextCursor = messages.isEmpty() ? null : 
            Cursor.from(messages.get(messages.size() - 1));
        
        return MessagePageResponse.of(messages, nextCursor, command.limit());
    }
}
```

#### 4.3 ë‹¨ë°œì„± ìŠ¤ì¼€ì¤„ ë“±ë¡

```java
@Service
@RequiredArgsConstructor
public class CreateOneTimeScheduleUseCase {
    private final ScheduleRuleRepository scheduleRepository;
    private final ChannelRepository channelRepository;
    private final MessageDomainService messageDomainService;
    private final ScheduleDomainService scheduleDomainService;
    private final QuartzSchedulerService quartzService;
    
    @Transactional
    public ScheduleResponse execute(CreateOneTimeScheduleCommand command) {
        // 1. ì±„ë„ ì¡°íšŒ
        Channel channel = channelRepository.findById(command.channelId())
            .orElseThrow(() -> new ChannelNotFoundException(command.channelId()));
        
        // 2. Early Return: ê¶Œí•œ ê²€ì¦
        if (!channel.isMember(command.senderId())) {
            throw new UnauthorizedAccessException("Not a member");
        }
        
        // 3. Early Return: ì‹œê°„ ê²€ì¦
        if (command.scheduledAt().isBefore(Instant.now())) {
            throw new InvalidScheduleTimeException("Cannot schedule in the past");
        }
        
        // 4. ë©”ì‹œì§€ ìƒì„± (ë„ë©”ì¸ ì„œë¹„ìŠ¤)
        Message message = messageDomainService.createMessage(
            command.channelId(),
            command.senderId(),
            command.content()
        );
        
        // 5. ìŠ¤ì¼€ì¤„ ìƒì„± (ë„ë©”ì¸ ì„œë¹„ìŠ¤)
        ScheduleRule schedule = scheduleDomainService.createOneTimeSchedule(
            message,
            command.scheduledAt()
        );
        
        // 6. ì €ì¥
        ScheduleRule saved = scheduleRepository.save(schedule);
        
        // 7. Quartz Job ë“±ë¡ (SimpleTrigger)
        quartzService.scheduleOneTimeJob(saved);
        
        return ScheduleResponse.from(saved);
    }
}
```

#### 4.4 ì£¼ê¸°ì  ìŠ¤ì¼€ì¤„ ë“±ë¡

```java
@Service
@RequiredArgsConstructor
public class CreateRecurringScheduleUseCase {
    private final ScheduleRuleRepository scheduleRepository;
    private final ChannelRepository channelRepository;
    private final MessageDomainService messageDomainService;
    private final ScheduleDomainService scheduleDomainService;
    private final QuartzSchedulerService quartzService;
    
    @Transactional
    public ScheduleResponse execute(CreateRecurringScheduleCommand command) {
        // 1. ì±„ë„ ì¡°íšŒ
        Channel channel = channelRepository.findById(command.channelId())
            .orElseThrow(() -> new ChannelNotFoundException(command.channelId()));
        
        // 2. Early Return: ê¶Œí•œ ê²€ì¦
        if (!channel.isMember(command.senderId())) {
            throw new UnauthorizedAccessException("Not a member");
        }
        
        // 3. ë©”ì‹œì§€ í…œí”Œë¦¿ ìƒì„±
        Message messageTemplate = messageDomainService.createMessage(
            command.channelId(),
            command.senderId(),
            command.content()
        );
        
        // 4. ì£¼ê¸° ìŠ¤ì¼€ì¤„ ìƒì„±
        ScheduleRule schedule = scheduleDomainService.createRecurringSchedule(
            messageTemplate,
            command.cronExpression()
        );
        
        // 5. ì €ì¥
        ScheduleRule saved = scheduleRepository.save(schedule);
        
        // 6. Quartz Cron Job ë“±ë¡
        quartzService.scheduleRecurringJob(saved);
        
        return ScheduleResponse.from(saved);
    }
}
```

#### 4.5 ê°•ì œ ë°œì†¡ (ë™ì‹œì„± ì œì–´)

```java
@Service
@RequiredArgsConstructor
public class ForcePublishScheduleUseCase {
    private final ScheduleRuleRepository scheduleRepository;
    private final MessageServerClient messageClient;
    private final QuartzSchedulerService quartzService;
    
    @Transactional
    public void execute(ForcePublishCommand command) {
        // 1. ë¹„ê´€ì  ë½ìœ¼ë¡œ ì¡°íšŒ (ë™ì‹œì„± ì œì–´)
        ScheduleRule schedule = scheduleRepository
            .findByIdWithLock(command.scheduleId())
            .orElseThrow(() -> new ScheduleNotFoundException(command.scheduleId()));
        
        // 2. Early Return: ìƒíƒœ ê²€ì¦
        if (!schedule.canBeExecuted()) {
            throw new InvalidScheduleStateException(
                "Schedule is not in executable state: " + schedule.getStatus()
            );
        }
        
        // 3. ë‹¨ë°œì„±ì¸ ê²½ìš° Quartz Job ì‚­ì œ
        if (schedule.isOneTime()) {
            quartzService.deleteJob(schedule.getId());
            schedule.markAsExecuted();
        }
        // ì£¼ê¸°ì ì¸ ê²½ìš° Jobì€ ìœ ì§€ (ë‹¤ìŒ ì‹¤í–‰ ëŒ€ê¸°)
        
        // 4. ë©”ì‹œì§€ ë°œì†¡ (chat-message-server REST í˜¸ì¶œ)
        messageClient.sendMessage(schedule.getMessage());
        
        // 5. ì €ì¥
        scheduleRepository.save(schedule);
    }
}
```

#### 4.6 Quartz Job êµ¬í˜„ (ë™ì‹œì„± ì œì–´)

```java
@Component
@DisallowConcurrentExecution  // â­ ì¤‘ìš”: ë™ì‹œ ì‹¤í–‰ ë°©ì§€
@RequiredArgsConstructor
public class MessagePublishJob implements Job {
    private final ScheduleRuleRepository scheduleRepository;
    private final MessageServerClient messageClient;
    
    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        String scheduleId = context.getJobDetail().getKey().getName();
        
        try {
            // 1. ë¹„ê´€ì  ë½ìœ¼ë¡œ ì¡°íšŒ
            ScheduleRule schedule = scheduleRepository
                .findByIdWithLock(ScheduleId.of(scheduleId))
                .orElseThrow(() -> new ScheduleNotFoundException(scheduleId));
            
            // 2. Early Return: ìƒíƒœ ê²€ì¦
            if (!schedule.canBeExecuted()) {
                return;
            }
            
            // 3. ë©”ì‹œì§€ ë°œì†¡
            messageClient.sendMessage(schedule.getMessage());
            
            // 4. ë‹¨ë°œì„±ì¸ ê²½ìš° ìƒíƒœ ì—…ë°ì´íŠ¸
            if (schedule.isOneTime()) {
                schedule.markAsExecuted();
                scheduleRepository.save(schedule);
            }
            // ì£¼ê¸°ì ì¸ ê²½ìš° ìƒíƒœëŠ” ìœ ì§€
            
        } catch (Exception e) {
            throw new JobExecutionException("Failed to publish message", e);
        }
    }
}
```

#### 4.7 QuartzSchedulerService

```java
@Service
@RequiredArgsConstructor
public class QuartzSchedulerService {
    private final Scheduler scheduler;
    
    public void scheduleOneTimeJob(ScheduleRule schedule) {
        JobDetail jobDetail = JobBuilder.newJob(MessagePublishJob.class)
            .withIdentity(schedule.getId().getValue())
            .usingJobData("scheduleId", schedule.getId().getValue())
            .build();
        
        Trigger trigger = TriggerBuilder.newTrigger()
            .withIdentity(schedule.getId().getValue() + "-trigger")
            .startAt(Date.from(schedule.getScheduledAt()))
            .build();
        
        scheduler.scheduleJob(jobDetail, trigger);
    }
    
    public void scheduleRecurringJob(ScheduleRule schedule) {
        JobDetail jobDetail = JobBuilder.newJob(MessagePublishJob.class)
            .withIdentity(schedule.getId().getValue())
            .usingJobData("scheduleId", schedule.getId().getValue())
            .storeDurably()  // Job ìœ ì§€
            .build();
        
        CronTrigger trigger = TriggerBuilder.newTrigger()
            .withIdentity(schedule.getId().getValue() + "-trigger")
            .withSchedule(CronScheduleBuilder.cronSchedule(schedule.getCronExpression().getValue()))
            .build();
        
        scheduler.scheduleJob(jobDetail, trigger);
    }
    
    public void deleteJob(ScheduleId scheduleId) {
        JobKey jobKey = JobKey.jobKey(scheduleId.getValue());
        scheduler.deleteJob(jobKey);
    }
}
```

---

### ğŸ”¹ Step 5: chat-websocket-server ë¦¬íŒ©í† ë§

#### 5.1 íŒ¨í‚¤ì§€ êµ¬ì¡°

```
chat-websocket-server/src/main/java/com/example/chat/websocket/
â”œâ”€â”€ application/
â”‚   â””â”€â”€ WebSocketMessageHandler.java
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ session/
â”‚   â”‚   â””â”€â”€ WebSocketSessionManager.java (Redis ê¸°ë°˜)
â”‚   â””â”€â”€ subscriber/
â”‚       â””â”€â”€ RedisMessageSubscriber.java
â””â”€â”€ config/
    â”œâ”€â”€ WebSocketConfig.java
    â””â”€â”€ RedisSubscriberConfig.java
```

#### 5.2 Redis ê¸°ë°˜ ì„¸ì…˜ ê´€ë¦¬ (ë©€í‹° ì¸ìŠ¤í„´ìŠ¤ ëŒ€ì‘)

```java
@Component
@RequiredArgsConstructor
public class WebSocketSessionManager {
    private final RedisTemplate<String, String> redisTemplate;
    
    // Redisì— ì„¸ì…˜ ì •ë³´ ì €ì¥
    // Key: "ws:channel:{channelId}:sessions"
    // Value: Set<sessionId>
    
    public void registerSession(String sessionId, ChannelId channelId) {
        String key = "ws:channel:" + channelId.getValue() + ":sessions";
        redisTemplate.opsForSet().add(key, sessionId);
    }
    
    public void unregisterSession(String sessionId, ChannelId channelId) {
        String key = "ws:channel:" + channelId.getValue() + ":sessions";
        redisTemplate.opsForSet().remove(key, sessionId);
    }
    
    public Set<String> getSessionsByChannel(ChannelId channelId) {
        String key = "ws:channel:" + channelId.getValue() + ":sessions";
        return redisTemplate.opsForSet().members(key);
    }
}
```

---

### ğŸ”¹ Step 6: ë¶ˆí•„ìš”í•œ íŒŒì¼ ì •ë¦¬

#### 6.1 .bak íŒŒì¼ ì‚­ì œ

```bash
# .bak íŒŒì¼ ì°¾ê¸° ë° ì‚­ì œ
find . -name "*.bak" -type f -delete
```

#### 6.2 ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” íŒ¨í‚¤ì§€/í´ë˜ìŠ¤ ì‚­ì œ

- [ ] chat-storageì˜ handler íŒ¨í‚¤ì§€ (factory íŒ¨í„´ì€ domainìœ¼ë¡œ ì´ë™)
- [ ] ê° ì„œë²„ì˜ domain íŒ¨í‚¤ì§€ (chat-domainìœ¼ë¡œ ì´ë™)
- [ ] ì¤‘ë³µëœ DTO í´ë˜ìŠ¤

---

### ğŸ”¹ Step 7: settings.gradle ìˆ˜ì •

```gradle
rootProject.name = 'chat-platform'

include 'common-util'
include 'common-auth'
include 'common-logging'

include 'chat-domain'          // â­ ì¶”ê°€
include 'chat-storage'

include 'chat-message-server'
include 'chat-system-server'
include 'chat-websocket-server'
```

---

### ğŸ”¹ Step 8: í…ŒìŠ¤íŠ¸ ë° ê²€ì¦

#### 8.1 ì»´íŒŒì¼ í™•ì¸

```bash
./gradlew clean build -x test
```

#### 8.2 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

```bash
./gradlew test
```

#### 8.3 í†µí•© í…ŒìŠ¤íŠ¸

- [ ] chat-message-server ê¸°ë™ í™•ì¸
- [ ] chat-system-server ê¸°ë™ í™•ì¸
- [ ] chat-websocket-server ê¸°ë™ í™•ì¸
- [ ] API í…ŒìŠ¤íŠ¸
- [ ] ìŠ¤ì¼€ì¤„ëŸ¬ ë™ì‘ í™•ì¸

---

## ğŸ“Š ë™ì‹œì„± ì œì–´ ì „ëµ ì •ë¦¬

### ë‹¨ë°œì„± ë©”ì‹œì§€ (ONE_TIME)

1. **DB ë¹„ê´€ì  ë½**: `SELECT ... FOR UPDATE`
2. **ìƒíƒœ ê²€ì¦**: `ScheduleStatus.PENDING` â†’ `EXECUTED`
3. **Quartz Job ì‚­ì œ**: ì‹¤í–‰ í›„ Job ì œê±°
4. **ë©”ì‹œì§€ ìƒíƒœ**: Messageì˜ `MessageStatus`ë¡œ ì¤‘ë³µ ë°œì†¡ ë°©ì§€

### ì£¼ê¸°ì  ë©”ì‹œì§€ (RECURRING)

1. **@DisallowConcurrentExecution**: Quartz ë ˆë²¨ ë™ì‹œ ì‹¤í–‰ ë°©ì§€
2. **DB ë¹„ê´€ì  ë½**: Job ì‹¤í–‰ ì‹œ ScheduleRule ë½ íšë“
3. **ë©”ì‹œì§€ ìƒˆë¡œ ìƒì„±**: ë§¤ë²ˆ ìƒˆë¡œìš´ MessageIdë¡œ ìƒì„± (ì¤‘ë³µ ì—†ìŒ)
4. **Job ìœ ì§€**: CronTriggerê°€ ê³„ì† ì‹¤í–‰

### ê°•ì œ ë°œì†¡ vs ìë™ ë°œì†¡ ì¶©ëŒ

```
ê°•ì œ ë°œì†¡ (ForcePublishScheduleUseCase)
    â†“
1. ScheduleRule ë¹„ê´€ì  ë½ íšë“
    â†“
2. ìƒíƒœ ê²€ì¦ (Early Return)
    â†“
3. ë‹¨ë°œì„±ì¸ ê²½ìš° Quartz Job ì‚­ì œ
    â†“
4. ë©”ì‹œì§€ ë°œì†¡
    â†“
5. ìƒíƒœ ì—…ë°ì´íŠ¸ â†’ EXECUTED
    â†“
6. ë½ í•´ì œ

ìë™ ë°œì†¡ (MessagePublishJob)
    â†“
1. ScheduleRule ë¹„ê´€ì  ë½ ì‹œë„
    â†“
    (ê°•ì œ ë°œì†¡ì´ ë½ì„ ì¡ê³  ìˆìœ¼ë©´ ëŒ€ê¸°)
    â†“
2. ë½ íšë“ í›„ ìƒíƒœ í™•ì¸
    â†“
3. ì´ë¯¸ EXECUTEDë©´ Early Return (ì¤‘ë³µ ë°©ì§€)
```

---

## ğŸ¯ ì²´í¬ë¦¬ìŠ¤íŠ¸

### Phase 1: Domain ê³„ì¸µ

- [ ] chat-domain ëª¨ë“ˆ ìƒì„±
- [ ] Channel Aggregate ì •ì˜
- [ ] Message Aggregate ì •ì˜
- [ ] ScheduleRule Aggregate ì •ì˜
- [ ] Repository Interface ì •ì˜
- [ ] Domain Service êµ¬í˜„
- [ ] Enum ì •ì˜ (MessageStatus, ScheduleStatus, ScheduleType ë“±)

### Phase 2: Storage ê³„ì¸µ

- [ ] chat-storage ë¦¬íŒ©í† ë§
- [ ] Entityì— Enum ì ìš©
- [ ] Adapter êµ¬í˜„
- [ ] Mapper êµ¬í˜„
- [ ] JpaConfig ìˆ˜ì •
- [ ] QueryDSL ì„¤ì •

### Phase 3: Server ëª¨ë“ˆ

- [ ] chat-message-server Use Case êµ¬í˜„
- [ ] chat-system-server Use Case êµ¬í˜„
- [ ] chat-websocket-server Redis ì„¸ì…˜ ê´€ë¦¬
- [ ] Early Return íŒ¨í„´ ì ìš©
- [ ] ì½”ë“œ ì»¨ë²¤ì…˜ ì¤€ìˆ˜

### Phase 4: í…ŒìŠ¤íŠ¸

- [ ] ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
- [ ] í†µí•© í…ŒìŠ¤íŠ¸
- [ ] API í…ŒìŠ¤íŠ¸
- [ ] ë™ì‹œì„± í…ŒìŠ¤íŠ¸

### Phase 5: ì •ë¦¬

- [ ] .bak íŒŒì¼ ì‚­ì œ
- [ ] ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì½”ë“œ ì œê±°
- [ ] ë¬¸ì„œí™”

---

## ğŸš€ ë‹¤ìŒ ë‹¨ê³„

ì´ì œ ì‹¤ì œ êµ¬í˜„ì„ ì‹œì‘í•©ë‹ˆë‹¤!

```
1. âœ… ì•„í‚¤í…ì²˜ ë¬¸ì„œ ì‘ì„± ì™„ë£Œ
2. âœ… ë§ˆì´ê·¸ë ˆì´ì…˜ ê³„íš ì‘ì„± ì™„ë£Œ
3. â¬œ Step 1: chat-domain ëª¨ë“ˆ ìƒì„±  â† ì—¬ê¸°ì„œë¶€í„° ì‹œì‘
```
