# 채팅 플랫폼 아키텍처 및 설계

> 이 문서는 기존 `채팅_어플리케이션_아키텍처_및_기획서.md`와 최근에 정리한 `채팅_어플리케이션_재설계_아키텍처_문서_초안.md`를 바탕으로, 실제 구현을 위한 재설계 결과를 정리한 문서입니다.

## 1. 개요

- 목표
  - DDD(Domain-Driven Design) + EDA(Event-Driven Architecture)를 기반으로 한 채팅 플랫폼을 설계한다.
  - 멀티 모듈 Gradle 프로젝트 구조를 정리하고, 실행 인스턴스별 책임과 경계를 명확히 한다.
  - 채팅방 관리, 채팅 메시지 발행/저장/전파, 예약 메시지, 다양한 메시지 타입, SaaS 확장 가능성을 고려한다.
- 실행 인스턴스(서버 프로세스)
  - `chat-message-server`
  - `chat-system-server`
  - `chat-websocket-server`
- 라이브러리/서포트 모듈
  - `common` (기존 `chat-common` 재구성)
  - `chat-storage`
  - (선택) `security`, `room-storage` 등

이하 섹션에서 멀티 모듈 구조, DDD 관점 Bounded Context, 이벤트 흐름, 모듈별 주요 플로우, 저장소 및 SaaS 전략을 순서대로 설명한다.

---

## 2. 멀티 모듈 구조 및 의존성

### 2.1. 전체 모듈 구조

- 루트 프로젝트: `chat-platform`
- 서브 모듈 개요
  - 실행 모듈 (Spring Boot 애플리케이션)
    - `chat-message-server`
    - `chat-system-server`
    - `chat-websocket-server`
  - 라이브러리/서포트 모듈
    - `common` (기존 `chat-common` 에서 재구성)
    - `chat-storage`
    - (선택) `security`, `room-storage` 등

### 2.2. 모듈별 역할

#### 2.2.1. `common` (공통 라이브러리 모듈 그룹)

- 성격: 순수 라이브러리 모듈 그룹 (어느 실행 모듈에서도 공통으로 사용)
- 구성: 3개의 서브 모듈로 세분화
  - `common-util`
  - `common-auth`
  - `common-logging`

**A. `common-util`**
- 책임
  - 공통 예외 계층
    - `BaseException`, `BaseErrorCode`, `ErrorCode` enum
    - `GlobalExceptionHandler` (Spring MVC 기반)
  - 공통 상수
    - HTTP 헤더 이름, 기본 페이지 크기, 공통 에러 메시지, 시스템 상수 등
  - 공통 유틸리티
    - 날짜/시간 처리 (`DateTimeUtil`)
    - ID 생성 (`IdGenerator`, UUID/Snowflake 등)
    - Validation Helper
    - 문자열/컬렉션 유틸
    - Cursor 관련 유틸 (`CursorCodec`, `Cursor`)
- 의존성
  - 외부 라이브러리 최소화 (순수 Java + Lombok 정도)
  - Spring Framework (예외 처리 등 필요 시)

**B. `common-auth`**
- 책임
  - 인증/인가 관련 공통 로직
    - JWT 토큰 생성/검증 (`JwtTokenProvider`)
    - 토큰 파싱 및 Claim 추출
    - 사용자 인증 정보 객체 (`AuthUser`, `UserPrincipal`)
    - Spring Security 통합 (Filter, Authentication 등)
  - 회원/사용자 식별 관련
    - `UserId` (Value Object)
    - 사용자 컨텍스트 홀더 (`UserContextHolder`, ThreadLocal 기반)
  - 권한 체크 어노테이션 및 AOP
    - `@RequireAuth`, `@RequireRole` 등
- 의존성
  - `common-util` (예외, 상수 등)
  - Spring Security
  - JWT 라이브러리 (예: jjwt)

**C. `common-logging`**
- 책임
  - 로깅 관련 공통 유틸리티 및 설정
    - MDC 처리 유틸 (`MdcUtil`)
    - 공통 HTTP 요청 로깅 필터 (`RequestLoggingFilter`)
    - TraceId, SpanId 생성 및 전파
    - 구조화 로그 포맷 정의
  - 향후 확장
    - ELK Stack, Grafana Loki 등 중앙 로그 수집 시스템 연동 대비
    - OpenTelemetry 통합 (분산 추적)
  - **현재는 바로 구현하지 않고, 추후 ELK Stack 등으로 전환할 때 본격 구현 예정**
- 의존성
  - `common-util` (상수 등)
  - SLF4J, Logback
  - (향후) Logstash Encoder, OpenTelemetry SDK

**의존성 방향**
```
common-util (최하위)
    ↑
    ├── common-auth
    └── common-logging

실행 모듈들 → 필요한 common 서브 모듈만 선택적으로 의존
```

**의존성 정책**
- `common` 서브 모듈들은 다른 프로젝트 모듈(`chat-storage`, 실행 서버 등)에 의존하지 않는다.
- 모든 실행 모듈은 필요한 `common` 서브 모듈에 의존할 수 있지만, 실행 모듈끼리 직접 순환 의존하지 않도록 설계한다.
- `common-util`을 기반으로 `common-auth`, `common-logging`이 확장하는 구조

#### 2.2.2. `chat-storage`

- 성격: 도메인 엔티티 및 영속성 계층 모듈
- 책임
  - 채팅 도메인 관련 모든 Entity, Repository, JPA 설정
  - 도메인별 패키지 구조 (예시)
    - `room`/`channel`: 채팅방, 채널, 참여자
    - `message`: 메시지, 메시지 상태, 메시지 읽음 정보
    - `schedule`: 예약 메시지 규칙, 스케줄 실행 로그
  - CQRS(Read/Write 분리)를 고려한 모델 구성
- 사용
  - `chat-message-server`, `chat-system-server` 에서 주입 받아 사용
  - (필요 시) `chat-websocket-server` 가 읽기 전용 조회에 사용 가능

#### 2.2.3. `chat-message-server`

- 성격: 메시지 발송/저장 API 서버 (실행 모듈)
- 책임
  - 외부/내부 클라이언트로부터 다양한 형태의 메시지 발송 요청을 수신 (REST API)
  - 메시지 검증 및 전처리 (권한, 포맷, 비즈니스 Rule)
  - `chat-storage` 를 이용하여 메시지 및 관련 정보를 저장
  - Redis Pub/Sub 을 통해 여러 인스턴스의 `chat-websocket-server` 에 메시지 전파
  - 메시지 읽음 처리 및 조회 API (예: `MessageReadController` 와 같은 역할)
- 의존성
  - `common`
  - `chat-storage`
  - `security` (JWT 인증/인가 등)

#### 2.2.4. `chat-system-server`

- 성격: 채팅 시스템 관리/비즈니스 API 서버 (실행 모듈)
- 책임
  - 채팅방 / 채널 생성, 수정, 삭제
  - 채팅방 참여/탈퇴, 초대 등 관리 기능
  - 채팅 메시지 조회 API
    - Offset 기반이 아닌 **Cursor 기반 페이징**으로 메시지 목록 제공
  - 예약 메시지(스케줄) 등록/수정/취소/조회
  - 예약 메시지 실행 로직 제어 (스케줄러와의 연계 포함)
  - 필요 시 `chat-message-server` 를 통해 실제 메시지 발송 트리거
- 의존성
  - `common`
  - `chat-storage`
  - (통신 방식에 따라) `chat-message-server` 와의 REST 호출 또는 이벤트 연동

#### 2.2.5. `chat-websocket-server`

- 성격: WebSocket 전용 서버 (실행 모듈)
- 책임
  - WebSocket 연결 수립/해제 및 세션 관리
  - 특정 채널/사용자에 대한 메시지 push
  - Redis Pub/Sub 구독을 통해 `chat-message-server` 가 발행한 메시지를 수신 후, 적절한 WebSocket 세션에 매핑하여 전송
  - 알림/전파 메시지 처리, 브로드캐스트/멀티캐스트/유저 단위 전송
- 의존성
  - `common`
  - `security`
  - (선택) `room-storage` 또는 `chat-storage` 의 일부 읽기 전용 사용

### 2.3. 모듈 간 의존성 방향

- `common` > (모든 실행 모듈)
- `chat-storage` > `chat-message-server`, `chat-system-server`, (선택) `chat-websocket-server`
- `chat-message-server`, `chat-system-server`, `chat-websocket-server` 는 서로 직접 순환 의존하지 않도록 한다.
  - `chat-system-server` 가 메시지 발송을 요청할 때는 REST 호출 또는 이벤트 발행을 통해 `chat-message-server` 를 간접적으로 사용한다.

---

## 3. DDD 관점 설계

### 3.1. Bounded Context 정의

주요 Bounded Context 는 다음과 같이 정의한다.

1. **Messaging BC**
   - 범위: 메시지 발송/저장/전파
   - 주요 모듈: `chat-message-server`, `chat-storage.message`
   - 책임
     - 메시지 엔티티 관리 (본문, 첨부, 메타데이터, 상태)
     - 메시지 발행/저장 트랜잭션 처리
     - 메시지 전달 이벤트 발행 (Redis Pub/Sub, Outbox 등)

2. **ChatRoom BC**
   - 범위: 채팅방, 채널, 참여자 관리
   - 주요 모듈: `chat-system-server`, `chat-storage.room/channel`
   - 책임
     - 채팅방/채널 생성, 속성 변경, 삭제
     - 방 참여/탈퇴, 권한 관리

3. **Schedule BC**
   - 범위: 예약 메시지 스케줄 관리
   - 주요 모듈: `chat-system-server`, `chat-storage.schedule`
   - 책임
     - 단발/주기 스케줄 규칙(ScheduleRule) 관리
     - 스케줄 상태(ScheduleState) 및 실행 이력 관리
     - 스케줄에 따른 메시지 발송 트리거 (주로 `chat-message-server` 와 연동)

4. **User/Member BC** (외부 시스템과 연동 가정)
   - 범위: 사용자/회원
   - 이 시스템에서는 주로 사용자 식별자/프로필 정도만 참조하고, 인증/회원 가입은 외부 서비스에 위임하는 것을 기본 가정으로 한다.

### 3.2. 도메인 모델 개략

예시 수준으로, 각 BC 별 주요 Aggregate 를 다음과 같이 상정한다.

- Messaging BC
  - `Message` (Aggregate Root)
    - `messageId`, `roomId`/`channelId`, `senderId`, `content`, `messageType`, `sentAt`, `status`
  - `MessageRead`
    - `messageId`, `readerId`, `readAt`

- ChatRoom BC
  - `ChatRoom` 또는 `Channel` (Aggregate Root)
    - `roomId`/`channelId`, `name`, `type`(1:1, 그룹, 공지 등), `createdAt`, `settings`
  - `Participant`
    - `userId`, `role`(owner, member 등), `joinedAt`

- Schedule BC
  - `ScheduleRule` (Aggregate Root)
    - `scheduleId`, `targetRoomId`/`targetUserId`, `messageTemplate`, `scheduleType`(단발/주기), `cronExpression` 또는 `executeAt`, `status`
  - `ScheduleExecutionLog`
    - `scheduleId`, `executionId`, `executedAt`, `resultStatus`, `errorMessage`

### 3.3. 계층 구조 (Layered Architecture)

각 실행 모듈은 대략 다음과 같은 레이어 구조를 따른다.

- API 레이어 (Controller)
  - REST / WebSocket 엔드포인트 정의
- 애플리케이션 서비스 레이어
  - 유스케이스/시나리오 단위의 트랜잭션 경계를 가진 서비스
- 도메인 레이어
  - 엔티티, Value Object, 도메인 서비스
- 인프라스트럭처 레이어
  - JPA Repository 구현체, 메시지 브로커 어댑터, Redis 클라이언트 등

---

## 4. 이벤트 드리븐 아키텍처 (EDA)

### 4.1. 이벤트 흐름 개요

- 기본 원칙
  - 상태 변경(메시지 생성, 예약 스케줄 생성/변경, 읽음 처리 등)은 도메인 이벤트로 표현한다.
  - 외부 시스템/다른 모듈에 알릴 필요가 있는 변경은 통합 이벤트(Integration Event) 로 변환하여 브로커(Redis Pub/Sub, 추후 Kafka/RabbitMQ)로 발행한다.

- 대표 이벤트 예시
  - `MessageCreatedEvent`
  - `MessageDeliveredEvent`
  - `MessageReadEvent`
  - `ScheduleCreatedEvent`
  - `ScheduleExecutedEvent`

### 4.2. 브로커 및 채널 설계

- Redis Pub/Sub (현재 설계 기준)
  - 역할: `chat-message-server` 에서 발행한 메시지를 다수의 `chat-websocket-server` 인스턴스로 팬아웃
  - 채널 설계 예시
    - `chat:room:{roomId}`
    - `chat:user:{userId}`

- 향후 확장성
  - 고부하/대규모 환경이나 기능 확장(알림, 분석 이벤트 등)을 위해 Kafka나 RabbitMQ 를 도입할 수 있도록 이벤트 모델을 브로커에 종속되지 않게 설계한다.

### 4.3. Outbox 패턴 (향후 적용 방향)

- 문제 인식
  - 메시지 저장(DB 트랜잭션)과 브로커 발행(Redis publish)이 분리되면, 중간 실패 시 데이터 손실/중복 위험이 있다.
- 해결 방향
  - `chat-message-server` + `chat-storage`에 Outbox 테이블을 도입하여, 메시지 저장과 Outbox 기록을 하나의 트랜잭션으로 처리한다.
  - 별도 Outbox 처리기(스케줄러/배치)가 Outbox 테이블을 폴링하며 브로커로 발행 후, 성공 시 상태를 업데이트한다.

---

## 5. 모듈별 주요 플로우

### 5.1. 메시지 발송 플로우 (`chat-message-server`)

1. 클라이언트가 REST API 로 메시지 발송 요청
2. 컨트롤러에서 인증/인가 및 요청 DTO 검증
3. 애플리케이션 서비스에서 도메인 규칙 검증(예: 권한, 방 상태, 메시지 길이 제한)
4. `chat-storage` 를 통해 메시지 엔티티 저장
5. 저장 성공 후 이벤트 생성
   - 간단한 구조에서는 바로 Redis Pub/Sub 으로 발행
   - Outbox 패턴 적용 시 Outbox 테이블에 기록
6. `chat-websocket-server` 가 Redis 구독을 통해 메시지 수신 후, 해당 세션으로 push

### 5.2. 메시지 조회 (Cursor 기반 페이징, `chat-system-server`)

1. 클라이언트가 특정 채팅방/채널의 메시지 목록을 요청, `cursor` 와 `limit` 를 함께 전달
   - `cursor` 는 마지막으로 조회한 메시지의 `messageId` 또는 `sentAt` 등의 기준값
2. 애플리케이션 서비스에서 권한 및 파라미터 검증
3. `chat-storage` 조회 시
   - `WHERE sent_at < :cursorSentAt ORDER BY sent_at DESC LIMIT :limit` 와 같은 형태로 구현
4. 결과와 함께 다음 페이지 요청을 위한 `nextCursor` 를 반환
5. 클라이언트는 `nextCursor` 를 사용해 추가 조회를 수행

### 5.3. 채팅방 관리 (`chat-system-server`)

- 채팅방 생성
  - 요청 → 검증 → `ChatRoom` Aggregate 생성 → `chat-storage` 저장 → 필요 시 이벤트 발행
- 채팅방 설정 변경/참여자 관리도 유사한 플로우로 처리

### 5.4. 예약 메시지 처리 (`chat-system-server` + 스케줄러)

- 예약 등록
  1. 클라이언트가 예약 메시지 생성 요청 (단발/주기, 시간/크론 표현식 포함)
  2. `ScheduleRule` Aggregate 생성 및 `chat-storage` 에 저장
  3. (Quartz 등 사용 시) 해당 Rule 에 대한 Job/Trigger 를 등록

- 실행 시나리오
  1. 스케줄러(Quartz 등)가 시각/크론에 맞춰 Job 실행
  2. Job 이 `chat-system-server` 또는 내부 서비스 로직을 호출
  3. 해당 시점의 Rule 상태/조건을 재검증 (취소/수정 여부 등)
  4. 최종적으로 `chat-message-server` 를 호출하여 실제 메시지 발송
  5. `ScheduleExecutionLog` 에 실행 결과 기록

- 동시 실행/중복 실행 방지 전략 (개략)
  - 단발성 스케줄
    - `ScheduleRule` 또는 해당 예약 메시지에 대해 상태 플래그를 두고, 상태 업데이트 시 낙관적 락/버전 필드를 사용하여 중복 실행 방지
  - 주기 스케줄
    - 메시지 단위가 아니라 `scheduleId + nextExecutionTime` 단위로 식별자/제약조건을 둬서, 동시에 같은 Slot 이 두 번 실행되지 않도록 설계
    - 또는 단발 Job 과 주기 Job 을 완전히 분리하여, 주기 Job 은 메시지 단위가 아닌 “주기 슬롯” 단위로만 보장

---

## 6. 공통 모듈 (`common`) 설계

### 6.1. 로깅

- 공통 로그 포맷 (JSON/구조화 로그)
- TraceId/SpanId, 사용자 ID, 요청 ID 를 MDC 에 담는 유틸리티 제공

### 6.2. 예외 및 에러 응답

- `BusinessException` + `ErrorCode` 기반 공통 예외 처리
- API 응답 포맷 통일 (성공/실패 모두 일정한 구조)

### 6.3. 유틸리티 및 상수

- 날짜/시간
- ID/토큰 관련
- Validation Helper 등

---

## 7. 저장소 및 데이터 모델 (`chat-storage`)

### 7.1. 주요 테이블(개략)

- `chat_room` / `channel`
  - 방/채널 메타데이터, 타입, 생성일, 설정값 등
- `message`
  - 메시지 본문/메타데이터, 발신자, 발송 시각, 상태
- `message_read`
  - 메시지별 읽음 정보 (사용자/시간)
- `schedule_rule`
  - 예약 메시지 규칙 (단발/주기, 시간/크론, 대상, 상태 등)
- `schedule_execution_log`
  - 스케줄 실행 이력 (성공/실패, 에러 메시지 등)

### 7.2. Read/Write 분리(CQRS)

- 쓰기
  - `source DB` 에서 메시지/방/스케줄을 저장 및 갱신
- 읽기
  - `replica DB` 를 이용해 조회 성능을 최적화
- 후속 단계에서 메시지/방 단위 샤딩도 고려 가능

---

## 8. SaaS / 멀티테넌트 고려

### 8.1. Tenant 개념 도입 위치

- 옵션 1: Row-level TenantId
  - 모든 주요 테이블(`chat_room`, `message`, `schedule_rule` 등)에 `tenant_id` 컬럼 추가
- 옵션 2: 스키마/DB 분리
  - 테넌트별로 별도 스키마 또는 DB 인스턴스를 할당

### 8.2. 현재 단계 기본 방침

- 초기 구현은 단일 테넌트 구조로 구현하되, 도메인 모델과 API 에서 Tenant 확장을 고려한 설계를 유지한다.
- 서로 다른 테넌트 간에 채팅방/메시지를 공유하지 않는 것을 기본 정책으로 한다.

---

## 9. 비기능 요구 및 운영

- 확장성
  - `chat-message-server`, `chat-system-server`, `chat-websocket-server` 를 각각 독립적으로 스케일 아웃 가능하게 설계
- 장애 격리
  - 메시지 발송 장애와 채팅방 관리 장애를 분리하여, 한 영역의 장애가 전체 서비스에 영향을 최소화하도록 한다.
- 모니터링/로깅
  - 공통 로깅 포맷 + APM/로그 수집 시스템(예: ELK, Grafana Loki 등) 연계
- 보안
  - `security` 모듈/의존성을 통한 JWT 기반 인증/인가, 권한 체크 정책 수립

---

## 10. 향후 확장 및 로드맵

- Outbox 패턴 정식 도입 및 이벤트 발행 인프라 고도화
- 메시지 타입 확장 (파일, 이미지, 시스템 알림, 봇 메시지 등)
- 고급 조회 기능 (검색, 필터링, 하이라이팅)
- SaaS 멀티테넌시 정식 지원 (Tenant 관리, Billing 연동 등)
- 대규모 트래픽 대응을 위한 메시징 브로커(Kafka/RabbitMQ) 도입 및 리팩토링

---

## 11. 프로젝트 재건 실행 계획 (STEP)

> 이 섹션은 기존 프로젝트를 위 아키텍처 설계에 맞춰 실제로 재구성하기 위한 구체적인 단계별 실행 계획입니다.

### 11.1. 현재 상태 분석

**현재 모듈 구조**
- `chat-common`: 공통 유틸, 예외, DTO, Port 인터페이스 등 혼재
- `chat-storage`: Entity, Repository, Adapter 등 영속성 계층
- `chat-message-server`: 메시지 발송 API 서버
- `chat-system-server`: 시스템 관리 API 서버
- `chat-websocket-server`: WebSocket 서버
- `domain`: (역할 불명확, 조사 필요)

**문제점 및 개선 목표**
1. `chat-common`에 도메인 특화 클래스(`ChatMessage`, `UserId`, Port 인터페이스 등)가 포함되어 있음
2. 순수 공통 유틸리티와 도메인 로직이 분리되지 않음
3. 다양한 메시지 타입 확장을 위한 전략 패턴/팩토리 구조가 명확하지 않음
4. 모듈 간 의존성 경계가 불명확함

### 11.2. STEP 1: `common` 모듈 세분화 및 재구성

**목표**: `chat-common`을 3개의 독립적인 서브 모듈(`common-util`, `common-auth`, `common-logging`)로 분리하여 명확한 책임 경계 확립

**배경**
- 기존 `chat-common`은 다양한 책임이 혼재되어 의존성 관리가 어려움
- 로깅, 인증, 유틸리티를 분리하여 필요한 모듈만 선택적으로 의존 가능하게 함
- 향후 확장성(ELK Stack, 외부 인증 시스템 연동 등)을 고려한 구조

**세부 작업**

#### A. 모듈 구조 생성

1. **`settings.gradle` 수정**
   ```groovy
   rootProject.name = 'chat-platform'
   
   // common 서브 모듈 3개 추가
   include 'common-util'
   include 'common-auth'
   include 'common-logging'
   
   include 'chat-storage'
   include 'chat-message-server'
   include 'chat-system-server'
   include 'chat-websocket-server'
   ```

2. **디렉토리 구조 생성**
   ```
   chat-platform/
   ├── common-util/
   │   ├── build.gradle
   │   └── src/main/java/com/example/chat/common/util/
   ├── common-auth/
   │   ├── build.gradle
   │   └── src/main/java/com/example/chat/common/auth/
   ├── common-logging/
   │   ├── build.gradle
   │   └── src/main/java/com/example/chat/common/logging/
   └── ...
   ```

#### B. `common-util` 모듈 구성

**책임**: 예외, 상수, 범용 유틸리티

**build.gradle**:
```groovy
plugins {
    id 'java-library'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

bootJar.enabled = false
jar.enabled = true

dependencies {
    // 최소 의존성
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    // Spring Framework (예외 처리용)
    implementation 'org.springframework:spring-web'
    implementation 'org.springframework:spring-context'
    
    // Jackson (JSON 처리)
    implementation 'com.fasterxml.jackson.core:jackson-databind'
}
```

**이관할 파일**:
- `exception/`
  - ✅ `BaseException.java`
  - ✅ `BaseErrorCode.java`
  - ✅ `ErrorCode.java`
  - ✅ `GlobalExceptionHandler.java` (Spring MVC)
- `constants/`
  - ✅ `MessageConstant.java`
  - ✅ HTTP 헤더, 시스템 상수 등
- `util/`
  - ✅ `CursorCodec.java`
  - ✅ `Cursor.java`
  - ✅ `ThrowReader.java`
  - ✅ `DateTimeUtil.java` (신규 작성)
  - ✅ `IdGenerator.java` (신규 작성)
  - ✅ `ValidationHelper.java` (신규 작성)

**제거할 항목** (다른 모듈로 이동):
- ❌ `dto/ChatMessage` → `chat-storage/domain/message/`로 이동
- ❌ `dto/UserId` → `common-auth`로 이동 (사용자 식별자이므로)
- ❌ `port/MessageService`, `port/MessageReadRepository` → `chat-storage` 또는 각 서버 모듈로 이동
- ❌ `logging/MdcUtil`, `logging/RequestLoggingFilter` → `common-logging`으로 이동

**패키지 구조**:
```
common-util/
└── src/main/java/com/example/chat/common/util/
    ├── exception/
    │   ├── BaseException.java
    │   ├── BaseErrorCode.java
    │   ├── ErrorCode.java
    │   └── GlobalExceptionHandler.java
    ├── constants/
    │   ├── MessageConstant.java
    │   ├── HeaderConstants.java
    │   └── SystemConstants.java
    └── util/
        ├── CursorCodec.java
        ├── Cursor.java
        ├── ThrowReader.java
        ├── DateTimeUtil.java
        ├── IdGenerator.java
        └── ValidationHelper.java
```

#### C. `common-auth` 모듈 구성

**책임**: 인증/인가, JWT, 사용자 컨텍스트

**build.gradle**:
```groovy
plugins {
    id 'java-library'
}

bootJar.enabled = false
jar.enabled = true

dependencies {
    // common-util 의존
    api project(':common-util')
    
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    // Spring Security
    implementation 'org.springframework.boot:spring-boot-starter-security'
    
    // JWT
    implementation 'io.jsonwebtoken:jjwt-api:0.12.3'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.3'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.3'
}
```

**구현할 클래스**:
- `jwt/`
  - `JwtTokenProvider.java`: JWT 생성/검증
  - `JwtProperties.java`: JWT 설정 (secret, expiration 등)
- `model/`
  - `UserId.java`: 사용자 식별자 VO (`chat-common`에서 이동)
  - `AuthUser.java`: 인증된 사용자 정보
  - `UserPrincipal.java`: Spring Security Principal 구현
- `filter/`
  - `JwtAuthenticationFilter.java`: JWT 필터
- `context/`
  - `UserContextHolder.java`: ThreadLocal 기반 사용자 컨텍스트
- `annotation/`
  - `@RequireAuth`: 인증 필요 표시
  - `@RequireRole`: 특정 권한 필요 표시
- `aspect/`
  - `AuthAspect.java`: 권한 체크 AOP

**패키지 구조**:
```
common-auth/
└── src/main/java/com/example/chat/common/auth/
    ├── jwt/
    │   ├── JwtTokenProvider.java
    │   └── JwtProperties.java
    ├── model/
    │   ├── UserId.java
    │   ├── AuthUser.java
    │   └── UserPrincipal.java
    ├── filter/
    │   └── JwtAuthenticationFilter.java
    ├── context/
    │   └── UserContextHolder.java
    ├── annotation/
    │   ├── RequireAuth.java
    │   └── RequireRole.java
    └── aspect/
        └── AuthAspect.java
```

#### D. `common-logging` 모듈 구성

**책임**: 로깅, 분산 추적, 향후 ELK Stack 연동 대비

**build.gradle**:
```groovy
plugins {
    id 'java-library'
}

bootJar.enabled = false
jar.enabled = true

dependencies {
    // common-util 의존
    api project(':common-util')
    
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    // SLF4J, Logback
    implementation 'org.slf4j:slf4j-api'
    implementation 'ch.qos.logback:logback-classic'
    
    // Spring Web (Filter 용)
    implementation 'org.springframework:spring-web'
    
    // (향후) Logstash Encoder
    // implementation 'net.logstash.logback:logstash-logback-encoder:7.4'
    
    // (향후) OpenTelemetry
    // implementation 'io.opentelemetry:opentelemetry-api'
}
```

**이관할 파일**:
- `MdcUtil.java` (`chat-common`에서 이동)
- `RequestLoggingFilter.java` (`chat-common`에서 이동)

**신규 구현할 클래스**:
- `trace/`
  - `TraceIdGenerator.java`: TraceId, SpanId 생성
  - `TraceContext.java`: 추적 컨텍스트
- `filter/`
  - `RequestLoggingFilter.java`: HTTP 요청 로깅
  - `MdcFilter.java`: MDC 설정 필터
- `config/`
  - `LoggingConfig.java`: 로깅 설정

**패키지 구조**:
```
common-logging/
└── src/main/java/com/example/chat/common/logging/
    ├── MdcUtil.java
    ├── trace/
    │   ├── TraceIdGenerator.java
    │   └── TraceContext.java
    ├── filter/
    │   ├── RequestLoggingFilter.java
    │   └── MdcFilter.java
    └── config/
        └── LoggingConfig.java
```

**⚠️ 중요**: `common-logging`은 초기 구현 단계에서는 기본 기능만 구현하고, **향후 ELK Stack, Grafana Loki, OpenTelemetry 등으로 전환할 때 본격적으로 확장**할 예정입니다.

#### E. 의존성 정리 및 검증

1. **각 실행 모듈의 `build.gradle` 수정**
   ```groovy
   // chat-message-server/build.gradle
   dependencies {
       implementation project(':common-util')
       implementation project(':common-auth')
       implementation project(':common-logging')
       implementation project(':chat-storage')
       // ...
   }
   
   // chat-system-server/build.gradle
   dependencies {
       implementation project(':common-util')
       implementation project(':common-auth')
       implementation project(':common-logging')
       implementation project(':chat-storage')
       // ...
   }
   
   // chat-websocket-server/build.gradle
   dependencies {
       implementation project(':common-util')
       implementation project(':common-auth')
       implementation project(':common-logging')
       // chat-storage는 선택적
       // ...
   }
   ```

2. **의존성 방향 검증**
   ```
   common-util (최하위, 의존성 없음)
       ↑
       ├── common-auth → common-util
       └── common-logging → common-util
   
   실행 모듈들 (chat-*-server) → 필요한 common 서브 모듈 선택적 의존
   ```

3. **순환 의존 체크**
   - `common-util`, `common-auth`, `common-logging`은 서로 의존하지 않음 (단, `common-auth`와 `common-logging`은 `common-util`에만 의존)
   - `common-*` 모듈들은 `chat-storage`나 실행 모듈에 의존하지 않음

#### F. 마이그레이션 체크리스트

- [ ] `settings.gradle`에 3개 서브 모듈 추가
- [ ] 각 서브 모듈 디렉토리 및 `build.gradle` 생성
- [ ] `chat-common`의 파일들을 적절한 서브 모듈로 이동
  - [ ] 예외/상수/유틸 → `common-util`
  - [ ] `UserId`, JWT 관련 → `common-auth`
  - [ ] 로깅 관련 → `common-logging`
- [ ] `ChatMessage`, Port 인터페이스 등은 `chat-storage` 또는 해당 서버 모듈로 이동
- [ ] 모든 실행 모듈의 import 경로 수정
  - `com.example.chat.common.*` → `com.example.chat.common.util.*`, `com.example.chat.common.auth.*` 등
- [ ] 빌드 성공 확인: `./gradlew build`
- [ ] 테스트 실행 및 검증

**예상 소요 시간**: 1-2일

**결과물**:
- 명확하게 분리된 3개의 `common` 서브 모듈
- 필요한 모듈만 선택적으로 의존할 수 있는 유연한 구조
- 향후 확장성(ELK, OAuth 등) 대비

---

## 12. STEP 실행 순서 요약

| 단계 | 내용 | 우선순위 | 예상 소요 |
|-----|------|---------|----------|
| STEP 1 | `common` 모듈 세분화 (common-util, common-auth, common-logging) | 높음 | 1-2일 |
| STEP 2 | `chat-storage` 확장 및 메시지 타입 전략 설계 | **최우선** | 3-4일 |
| STEP 3 | `chat-message-server` 재구성 | 높음 | 3-5일 |
| STEP 4 | `chat-system-server` 재구성 | 높음 | 4-5일 |
| STEP 5 | `chat-websocket-server` 재구성 | 중간 | 2-3일 |
| STEP 6 | `domain` 모듈 평가 및 통합 | 중간 | 1일 |
| STEP 7 | 빌드 설정 정리 | 높음 | 1일 |
| STEP 8 | 확장성 검증 테스트 | 중간 | 2-3일 |
| STEP 9 | 문서화 | 낮음 | 2-3일 |

**총 예상 소요**: 약 3-4주

**주요 개선 사항**:
- ✅ `common` 모듈을 3개 서브 모듈로 세분화하여 명확한 책임 분리
- ✅ `common-util`: 예외, 상수, 범용 유틸리티
- ✅ `common-auth`: JWT, 인증/인가, 사용자 컨텍스트
- ✅ `common-logging`: 로깅, 분산 추적 (향후 ELK Stack 연동 대비)
- ✅ 다양한 메시지 타입 확장을 위한 전략/팩토리 패턴 적용
- ✅ Cursor 기반 메시지 조회
- ✅ 예약 메시지 스케줄링 (단발/주기, 중복 실행 방지)

---

## 13. 핵심 설계 원칙

1. **개방-폐쇄 원칙 (OCP)**: 새 메시지 타입 추가 시 기존 코드 수정 불필요
2. **전략 패턴**: MessageHandler로 타입별 로직 분리
3. **팩토리 패턴**: MessageFactory로 생성 로직 캡슐화
4. **의존성 역전**: 인터페이스 기반 확장
5. **단일 책임**: 각 모듈/클래스는 하나의 명확한 책임
