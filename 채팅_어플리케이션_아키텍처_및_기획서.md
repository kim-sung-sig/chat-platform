# 채팅 어플리케이션 아키텍처 및 기획서

## 1. 목적
- 현재 설계한 클래스 다이어그램을 바탕으로 전반적인 아키텍처와 컴포넌트 책임을 명확히 정리합니다.
- 멀티 모듈 프로젝트 구조, 메시지 전달 흐름(RabbitMQ), 상태 공유(Redis), CQRS 적용 등 구현·운영 지침을 제공합니다.

---

## 2. 개요 요약
- 멀티모듈: `websocket-server`, `message-server`, `common`(또는 commonModule), `storage` 등으로 분리.
- 실행 가능 모듈: `websocket-server`, `message-server`만 `bootRun` 가능.
- 메시지 브로커: RabbitMQ (교환/라우팅 사용).
- 채팅 참여자 관리: Redis (여러 인스턴스 간 공유 가능한 구조).
- 메시지 저장: CQRS — `source DB`(쓰기, 정합성 보장), `replica DB`(읽기, 조회성능) — 추후 샤딩 고려.
- 인증/권한: JWT 혹은 redisSession을 사용하며, 인증 데이터 구조는 `common`모듈에서 정의.

---

## 3. 모듈별 책임 (High Level)

### 3.1 common
- 사용자 식별자(`UserId`, `User`), 공통 응답(`ApiResponse`), 에러 코드(`ErrorCode`, `BaseException`) 정의
- 공통 DTO, 인증/권한 관련 유틸

### 3.2 websocket-server
- 역할: 클라이언트 WebSocket 연결 관리, 클라이언트로부터 메시지 수신, 알림 전송
- 컴포넌트
  - Listener
    - `MessageListener` : 현재 참여중인 채팅방에 속한 유저에게 실시간 메시지 푸시
    - `NotificationListener` : 미참여자에게 푸시 알림(푸시 토큰 또는 소켓 후속 연결)
  - Register
    - `ChatRoomRegister` : 채팅방-참여자 매핑 관리 (Redis 기반)
  - API(Controller)
    - WebSocket 엔드포인트, REST API(채팅방 목록/메타데이터 조회 등)
- 고려사항
  - 여러 인스턴스에서 동일 채팅방에 대한 동시성 문제: Redis를 통한 분산 락/카운팅 활용
  - 연결 유지 및 재연결 전략

### 3.3 message-server
- 역할: 메시지 처리의 핵심 비즈니스 로직(CQRS 적용)
- 컴포넌트
  - Usecase(Service)
    - `MessageService` : sendMessage, editMessage(선택), deleteMessage, fetchHistory 등
    - `ChannelService` : 채널 생성/종료/권한 관리
  - Domain
    - Entities: `ChatChannel`, `ChatChannelUser`, `ChatMessage`, `ChatMessageReadByUser`, `ChatMessagePublisher`
    - Validators: `ChannelValidator`(예: `AlarmChannelValidator`, `EnterChannelValidator`), `MessageValidator`(예: `MessageSendValidator`)
  - Repository (CQRS 분리)
    - `messageReader`(read-only, replica DB), `messageRepository`(write, source DB)
    - 채널도 `channelReader` / `channelRepository` 분리
  - Message Publisher
    - RabbitMQ로 메시지 발행(일관된 이벤트 포맷 사용)
- 고려사항
  - 트랜잭션 경계: write 작업은 source DB에서 트랜잭션 보장 후 이벤트 발행
  - Dirty checking 트릭: `messageStatus` 필드를 통해 JPA 더티체킹을 활용한 상태 변경 감지

### 3.4 storage
- DB 모델과 JPA 엔티티 구현
  - `ChatMessageEntity`는 `messageStatus` 같은 필드를 포함해 update 시점을 트래킹
- JPA repository (Spring Data JPA)
- DB 설계: 인덱싱(채널ID+생성일), 파티셔닝/샤드 고려

---

## 4. 상세 설계

### 4.1 도메인 모델 (주요 엔티티)
- `ChatChannel`
  - id, name, type(public/private), metadata, createdAt
  - 비즈니스: 입장 제한, 알람 설정, 보관 규칙
- `ChatChannelUser`
  - id, channelId, userId, role(owner/admin/member), joinedAt
- `ChatMessage`
  - id, channelId, senderId, content, type(text/image/etc), status(DELIVERED/READ/SENT), createdAt
  - messageStatus 필드로 읽음 처리 등 상태 변경을 JPA 더티체킹으로 적용
- `ChatMessageReadByUser`
  - composite key(channelId, messageId, userId), readAt
- `ChatMessagePublisher`
  - 이벤트 포맷: messageId, channelId, senderId, payload, timestamp, eventType

### 4.2 도메인 서비스와 검증
- `ChannelValidator`
  - `EnterChannelValidator`: 입장 권한, 차단 여부, 채널 상태 검증
  - `AlarmChannelValidator`: 알림 수신 여부/권한 검증
- `MessageValidator`
  - `MessageSendValidator`: 채널 존재 여부 + content 검증(길이, 금지어 등)

### 4.3 레포지토리 전략 (CQRS)
- **Write side** (`messageRepository`, `channelRepository`)
  - 트랜잭션이 필요. source DB에 쓰기.
  - 이벤트 발행은 DB 커밋 성공 후(예: outbox pattern 또는 트랜잭션-내부 outbox 테이블 사용).
- **Read side** (`messageReader`, `channelReader`)
  - replica DB나 read-optimized 스토어에서 조회. 조회 쿼리는 인덱스/캐시 활용.
- Outbox Pattern 권장: source DB에 outbox 테이블에 이벤트 저장 -> 별도 프로세스가 읽어 RabbitMQ에 발행

### 4.4 메시지 흐름 (시퀀스)
1. 클라이언트 -> websocket-server: 메시지 전송 요청
2. websocket-server -> message-server (RPC or publish to exchange)
   - 권한/입장 검증을 우선 수행(예: JWT 검사)
3. message-server: `MessageService`에서 검증 후 source DB에 저장(트랜잭션)
4. 트랜잭션 커밋 완료 -> outbox에 이벤트 저장 또는 바로 RabbitMQ 발행
5. RabbitMQ 교환(exchange) 통해 routing key에 따라 `websocket-server` 인스턴스(또는 notification worker)로 배포
6. websocket-server: 해당 채널에 참여한 사용자 목록(=Redis) 조회 -> 참여자에게 실시간 푸시
7. 읽음 처리(read by user)는 별도 이벤트로 처리하여 `ChatMessageReadByUser` 업데이트 및 읽음 상태 브로드캐스트

> 비동기 메시지/이벤트는 항상 포맷(스키마)을 엄격히 정의하고 버전 관리(V1, V2)를 적용

### 4.5 Redis 사용
- **채널-참여자 매핑(실시간 상태)**
  - Key: `channel:{channelId}:users` (Set)
  - Value: userId 또는 user session meta (접속 시간, socketId)
- **세션/권한**
  - JWT 토큰은 stateless, 필요시 redisSession으로 추가 메타(차단, 권한 변경)를 저장
- **분산 락/카운터**
  - 입장 동시성 제어(예: 최대 인원 제한)에는 Redisson 분산 락 사용 권장

---

## 5. API / 이벤트 사양 (예시)

### 5.1 REST / WebSocket 엔드포인트 예시
- WebSocket: `ws://host/ws` 연결, STOMP 엔드포인트 `/ws` (선택)
- 메시지 전송(WS)
  - Destination: `/app/room/{channelId}/send`
  - Payload: `{ "senderId": "..", "content": "..", "type": "TEXT" }`
- REST
  - `GET /api/channels/{channelId}/messages?cursor=&limit=` -> messageReader 사용
  - `POST /api/channels` -> 채널 생성

### 5.2 메시지 이벤트 (RabbitMQ) 예시
- Exchange: `chat.exchange` (type: topic)
- Routing key
  - `chat.channel.{channelId}.message` -> 참여자 푸시
  - `chat.user.{userId}.notification` -> 개인 알림
- Payload (JSON)
  - `{ "eventType":"MESSAGE_CREATED", "data": { "messageId":"..", "channelId":"..", "senderId":"..", "content":"..", "createdAt":".." } }

---

## 6. 데이터베이스 설계 고려사항
- 인덱스: `channelId + createdAt`, `userId + channelId` 등
- 파티셔닝: 대형 채널(수백만 메시지)은 파티셔닝 고려
- 샤딩 전략: 추후 `channel` 단위 샤딩 고려(채널별로 소유 DB로 분배)
- 보관 정책: 메시지 만료/아카이브 정책(예: 오래된 메시지 S3로 아카이브)

---

## 7. 운영/배포/스케일링
- websocket-server: sticky-session이 필요없도록 설계(Redis로 세션 공유, 소켓 메타 저장)
- message-server: stateless하게 설계, 수평 확장 가능
- RabbitMQ: 고가용성(클러스터, mirrored queues), 모니터링
- DB: master(source)/replica 패턴; 읽기 분산을 위해 읽기 라우팅
- 모니터링: Prometheus + Grafana, 로그: ELK 또는 EFK
- 장애대응: 메시지 재시도 정책, Dead Letter Queue (DLQ) 설정

---

## 8. 보안 및 권한
- 인증: JWT 기반 인증. 민감한 연산(메시지 삭제, 채널관리)은 권한 체크 추가
- 암호화: 전송 계층 TLS, 메시지 페이로드에 민감 데이터가 있으면 암호화 고려
- Rate limit: API 및 WS 메시지 보내기 제한
- 감사 로그: 메시지 삭제/수정/관리자 액션 기록

---

## 9. 테스트 전략
- 단위 테스트: Validator, Domain Service
- 통합 테스트: message-server 쓰기-읽기 경로, RabbitMQ 연동 테스트(테스트용 브로커)
- 부하 테스트: 실제 수평 확장 시의 메시지 지연 및 Redis 접근량 측정

---

## 10. 추가 권장 사항 / 확장 포인트
1. **Outbox Pattern**: DB 트랜잭션과 이벤트 발행 일관성 보장.
2. **Idempotency**: 중복 이벤트 처리 대비 idempotency 키 설계.
3. **메시지 버저닝**: 이벤트 스키마 버전 관리.
4. **읽기 최적화**: 최근 메시지 캐싱(LRU)이나 Redis Streams/SortedSet 사용 검토.
5. **오프라인 푸시**: 미참여 사용자나 모바일 푸시 연동 (FCM, APNs)
6. **운영성**: 메시지 보관/삭제 정책과 컴플라이언스(로그 보존 정책) 문서화.

---

## 11. 예시 클래스/인터페이스 (핵심)
```java
public interface MessageService {
    void sendMessage(SendMessageCommand cmd);
    Page<MessageDto> fetchMessages(String channelId, Cursor cursor);
}

public interface ChatRoomRegister {
    void addUserToChannel(String channelId, String userId, SessionMeta meta);
    void removeUserFromChannel(String channelId, String userId);
    Set<String> listUsers(String channelId);
}
```

---

## 12. 다음 단계(실행 계획)
1. 핵심 도메인(메시지 / 채널) 엔티티와 DB 스키마 확정
2. 이벤트 스키마 정의 및 RabbitMQ 토폴로지 설계
3. Redis 키 설계 및 TTL 정책 정의
4. outbox 구현 방식 결정(배치 vs CDC 기반 등)
5. 프로토타입: 작은 그룹 채널에서 end-to-end (WS->message-server->Rabbit->WS) 구현
6. 부하 테스트 및 인덱스/쿼리 튜닝

---

문서에서 더 자세히 보고 싶은 항목(예: ERD, 시퀀스 다이어그램, API 스펙 상세, 메시지 JSON 스키마)을 알려주면 해당 부분을 바로 확장해서 추가합니다.

