# 객체지향 설계를 강제하는 코딩 컨벤션 가이드

이 문서는 단순한 코드 스타일 규칙이 아니다.  
설계 사고방식을 통제하고, 객체지향 원칙을 강제하기 위한 기준 문서이다.

---

# 1단계: 정체성 정의 (Identity Declaration)

모든 구현은 다음 정체성을 전제로 한다.

> 우리는 객체지향 설계를 기반으로 개발한다.  
> 모든 코드는 SOLID 원칙을 준수해야 한다.  
> 데이터가 아닌 객체를 설계한다.

### 핵심 철학

- 객체는 데이터 덩어리가 아니다.
- 객체는 **상태 + 행위 + 책임**을 가진다.
- 시스템은 객체 간 협력으로 구성된다.
- 절차적 사고를 배제한다.
- 모델 중심 사고(Model-Driven Thinking)를 유지한다.

---

# 2단계: 행동 규칙 정의 (Design Rules)

## 2.1 SOLID 원칙 준수

### SRP (Single Responsibility Principle)
- 모든 클래스는 단 하나의 책임만 가진다.
- 책임이 두 개 이상이면 반드시 분리한다.

### OCP (Open/Closed Principle)
- 확장에는 열려 있고 변경에는 닫혀 있어야 한다.
- 조건문 추가로 기능을 확장하지 않는다.
- 다형성을 우선 고려한다.

### LSP (Liskov Substitution Principle)
- 하위 타입은 상위 타입을 대체 가능해야 한다.
- 상속은 행위 보존이 가능할 때만 허용한다.

### ISP (Interface Segregation Principle)
- 사용하지 않는 메서드를 강제하지 않는다.
- 작은 인터페이스를 설계한다.

### DIP (Dependency Inversion Principle)
- 구현이 아니라 추상에 의존한다.
- 객체 생성 책임은 외부로 위임한다.
- new 키워드 사용을 최소화한다.

---

## 2.2 객체 설계 원칙

1. 객체는 단순 DTO가 되어서는 안 된다.
2. 비즈니스 로직은 도메인 모델 내부에 위치한다.
3. 서비스 계층은 오케스트레이션 역할만 수행한다.
4. getter/setter 중심 설계를 지양한다.
5. 내부 상태는 외부에서 직접 수정할 수 없게 한다.
6. 불변성을 우선 고려한다.
7. 메시지 기반 협력 구조를 설계한다.
8. 조건문 분기 대신 다형성을 활용한다.
9. 컬렉션은 외부에 그대로 노출하지 않는다.
10. 모델의 의도가 메서드 이름에 드러나야 한다.

---

# 3단계: 금지 사항 (Anti-Patterns)

다음 구조는 허용하지 않는다.

## 3.1 Anemic Domain Model

- 엔티티에 getter/setter만 존재
- 모든 로직이 서비스에 집중
- 객체가 데이터 컨테이너로만 사용됨

## 3.2 절차적 분기 구조

- enum + if/when 분기 처리
- 타입 코드 기반 조건 분기
- switch로 행위 결정

## 3.3 책임 과다 객체

- 하나의 클래스가 검증 + 계산 + 저장 + 변환 수행
- 서비스가 비즈니스 로직을 모두 포함

## 3.4 무분별한 객체 생성

- 내부에서 직접 new 호출
- 의존성 주입 없이 구현체 직접 참조

## 3.5 상태 노출

- public 필드
- 내부 컬렉션 직접 반환
- 외부에서 상태 변경 가능 구조

## 3.6 Reflection 사용
- 객체 생성이나 필드 접근에 Reflection 사용 구조

## 3.7 체이닝 과사용
- createTest(params).methodA() >> var testModel = createTest(params); testModel.methodA();

---

# 4단계: 추천 사항
다음 구조는 지향한다.

## 4.1 모델 중심 설계
- 도메인 모델이 핵심 로직을 포함
- 서비스는 모델 간 협력 조정 역할
- 객체가 스스로 행동하는 구조
- 모델의 의도가 명확히 드러나는 메서드 설계

## 4.2 Record 타입 활용
- 불변 데이터 표현에 Record 타입 활용
- DTO 대신 Record로 간결한 데이터 전달
- 모델의 의도가 드러나는 메서드 이름 사용
- Record 의 compact constructor 활용하여 가독성 향상 및 검증 로직 포함

## 4.3 다형성 활용
- 조건문 대신 인터페이스와 구현체 활용
- 행위에 따른 클래스 분리로 책임 명확화
- 새로운 기능 추가 시 기존 코드 수정 없이 확장 가능
- 상속보다는 컴포지션을 우선 고려하여 유연한 구조 설계
- 인터페이스를 통한 느슨한 결합으로 테스트 용이성 향상
- 객체 간 협력 구조를 명확히 하여 시스템의 의도를 드러내는 설계 지향

## 4.4 메시지 기반 협력
- 객체 간 협력은 메시지 전달로 이루어진다.
- 객체는 자신의 상태를 스스로 관리하고, 필요한 정보를 요청하는 메시지를 통해 협력한다.
- 메시지 기반 설계는 객체 간의 결합도를 낮추고, 시스템의 유연성과 확장성을 높인다.

---

# 설계 점검 질문 체크리스트

코드를 작성하기 전에 반드시 스스로에게 질문한다.

- 이 객체의 책임은 하나인가?
- 이 로직은 이 객체가 가져야 하는가?
- 데이터가 아니라 객체가 말하고 있는가?
- 조건문을 제거할 수 있는 구조인가?
- 확장을 위해 기존 코드를 수정해야 하는가?
- 서비스가 아닌 도메인이 핵심 로직을 가지고 있는가?

---

# 최종 목표

우리가 만드는 시스템은 다음 특성을 가져야 한다.

- 변경에 강하다.
- 확장이 쉽다.
- 테스트 가능하다.
- 객체 간 협력이 명확하다.
- 데이터 중심이 아닌 모델 중심 설계다.

---

이 문서는 코드 스타일을 통제하기 위한 것이 아니라  
설계 수준을 통제하기 위한 기준 문서이다.
